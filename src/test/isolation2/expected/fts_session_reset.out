-- This test performs segment reconfiguration when a distributed
-- transaction is in progress. The expectation is that the first
-- command in the transaction after reconfiguration should fail. It
-- verifies a bug where a stale gang was reused in such a case, if the
-- failed primary happened to be up and listening.

-- set these values purely to cut down test time, as default ts trigger is
-- every min and 5 retries
alter system set gp_fts_probe_interval to 10;
ALTER
alter system set gp_fts_probe_retries to 0;
ALTER
select pg_reload_conf();
 pg_reload_conf 
----------------
 t              
(1 row)

create table test_fts_session_reset(c1 int);
CREATE

CREATE or REPLACE FUNCTION wait_until_primary_down() RETURNS VOID AS $$ begin /* in func */ for i in 1..120 loop /* in func */ if (select status = 'd' from gp_segment_configuration where content = 0 and role = 'm') then /* in func */ return; /* in func */ end if; /* in func */ perform pg_sleep(1); /* in func */ end loop; /* in func */ end; /* in func */ $$ language plpgsql;
CREATE

1:BEGIN;
BEGIN
-- let the dispatcher create a gang
1:insert into test_fts_session_reset select * from generate_series(1,20);
INSERT 20
1:select gp_inject_fault('fts_conn_startup_packet', 'error', dbid) from gp_segment_configuration where role='p' and content=0;
 gp_inject_fault 
-----------------
 Success:        
(1 row)
1:select gp_request_fts_probe_scan();
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)
1:select wait_until_primary_down();
 wait_until_primary_down 
-------------------------
                         
(1 row)
-- At this point, content 0 mirror is promoted and the primary is marked down.
-- the gang used by the previous insert is no longer valid. It must be destroyed
-- and the transaction must be aborted.
1:insert into test_fts_session_reset select * from generate_series(21,40);
ERROR:  gang was lost due to cluster reconfiguration (cdbgang_async.c:94)
1:select count(*) from test_fts_session_reset;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
1:END;
END
1:select count(*) from test_fts_session_reset;
 count 
-------
 0     
(1 row)
2:select gp_inject_fault('fts_conn_startup_packet', 'reset', dbid) from gp_segment_configuration where content=0;
 gp_inject_fault 
-----------------
 Success:        
 Success:        
(2 rows)
1q: ... <quitting>
2q: ... <quitting>

-- expect one primary is down and mirror is promoted to primary
select content, preferred_role, role, status, mode from gp_segment_configuration where content = 0 order by role;
 content | preferred_role | role | status | mode 
---------+----------------+------+--------+------
 0       | p              | m    | d      | n    
 0       | m              | p    | u      | n    
(2 rows)

!\retcode gprecoverseg -aF --no-progress;
-- start_ignore
-- end_ignore
(exited with code 0)

-- loop while segments come in sync
select wait_until_all_segments_synchronized();
 wait_until_all_segments_synchronized 
--------------------------------------
 OK                                   
(1 row)

!\retcode gprecoverseg -ar;
-- start_ignore
-- end_ignore
(exited with code 0)

-- loop while segments come in sync
select wait_until_all_segments_synchronized();
 wait_until_all_segments_synchronized 
--------------------------------------
 OK                                   
(1 row)

-- verify no segment is down after recovery
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

alter system reset gp_fts_probe_interval;
ALTER
alter system reset gp_fts_probe_retries;
ALTER
select pg_reload_conf();
 pg_reload_conf 
----------------
 t              
(1 row)

